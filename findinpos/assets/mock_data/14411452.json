{"by":"detaro","id":14411452,"parent":14411398,"text":"their earlier blogpost goes into it a bit <a href=\"https:&#x2F;&#x2F;blogs.msdn.microsoft.com&#x2F;bharry&#x2F;2017&#x2F;02&#x2F;03&#x2F;scaling-git-and-some-back-story&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;blogs.msdn.microsoft.com&#x2F;bharry&#x2F;2017&#x2F;02&#x2F;03&#x2F;scaling-g...</a> :<p><i>The first big debate was – how many repos do you have – one for the whole company at one extreme or one for each small component?  A big spectrum.  Git is proven to work extremely well for a very large number of modest repos so we spent a bunch of time exploring what it would take to factor our large codebases into lots of tenable repos.  Hmm.  Ever worked in a huge code base for 20 years?  Ever tried to go back afterwards and decompose it into small repos?  You can guess what we discovered.  The code is very hard to decompose.  The cost would be very high.  The risk from that level of churn would be enormous.  And, we really do have scenarios where a single engineer needs to make sweeping changes across a very large swath of code.  Trying to coordinate that across hundreds of repos would be very problematic.<p>After much hand wringing we decided our strategy needed to be “the right number of repos based on the character of the code”.  Some code is separable (like microservices) and is ideal for isolated repos.  Some code is not (like Windows core) and needs to be treated like a single repo.</i>","time":1495644878,"type":"comment"}